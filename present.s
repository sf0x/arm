.syntax unified

/*
 * TODO:
 * Implement the following function:
 * 	void PRESENT128_decrypt_asm(uint8_t state[8], uint8_t roundkeys[32][8]);
 *  - The roundkeys array can be seen as 32*8 consecutive bytes in memory and R1 points to the first word.
 *    This means that [R1] and [R1+4] are the first round key, [R1+8] and [R1+12] the second and so on.
 *  - The plaintext has to be written back to the state array in the end.
 *  - The following code already contains a suggestion for you. You can change it if you want.
 */
.global PRESENT128_decrypt_asm
PRESENT128_decrypt_asm:
	// bind aliases
	state		.req R0
	roundkeys 	.req R1
	counter 	.req R2

	// functions calling functions, so store LR
	PUSH {LR}

	// load initial states into temp registers
	ldr r3,[r0]
	add r0,#0x4		// move to second word
	ldr r4,[r0]
	sub r0,#0x4		// move back to the start offset

	// revert last add round key
	mov counter,#0x20
	BL revert_add_round_key

	// revert all the rounds
	MOV counter, #31
	revert_present_rounds:
		BL revert_p_layer
		BL revert_sbox
		BL revert_add_round_key

		SUBS counter, #1
		BNE revert_present_rounds

	// save final state into memory
	str r3,[r0]
	add r0,#0x4		// move pointer to second word
	str r4,[r0]

	// restore LR into PC -> return from function
	POP {PC}

	// unbind aliases
	.unreq state
	.unreq roundkeys
	.unreq counter



revert_add_round_key:
	push {r7-r12,lr}


	sub r5,r2,#0x1	// lower key round by one
	lsl r7,r5,#0x3	// multiply round by 8 to get correct roundkey offset

	ldr r8,[r1,r7]	// load roundkey[32][0]
	add r7,#0x4
	ldr r9,[r1,r7]	// load roundkey[32][4]

	eor r3,r8		// xor word[0] + roundkey[0]
	eor r4,r9		// xor word[4] + roundkey[4]

	pop {r7-r12,pc}



revert_p_layer:
	push {r7-r12,lr}

	eor r6,r6			// clear
	eor r7,r7			// clear
	eor r8,r8			// clear

	// following: precalculated bit permutations
	// will comment only the first occurences,
	// since the following operations are equal

	ubfx r5,r3,#0x00,#0x1		// get bit b0 from state, write it to r5
	bfi r7,r5,#0x0,#0x1			// write bit to target tmp register

	ubfx r5,r3,#0x10,#0x1		// from here, same as above with all the bits
	bfi r7,r5,#0x1,#0x1

	ubfx r5,r4,#0x0,#0x1
	bfi r7,r5,#0x2,#0x1

	ubfx r5,r4,#0x10,#0x1
	bfi r7,r5,#0x3,#0x1
	//
	ubfx r5,r3,#0x01,#0x1
	bfi r7,r5,#0x4,#0x1

	ubfx r5,r3,#0x11,#0x1
	bfi r7,r5,#0x5,#0x1

	ubfx r5,r4,#0x01,#0x1
	bfi r7,r5,#0x6,#0x1

	ubfx r5,r4,#0x11,#0x1
	bfi r7,r5,#0x7,#0x1

	// second byte

	ubfx r5,r3,#0x02,#0x1
	bfi r7,r5,#0x8,#0x1

	ubfx r5,r3,#0x12,#0x1
	bfi r7,r5,#0x9,#0x1

	ubfx r5,r4,#0x02,#0x1
	bfi r7,r5,#0xa,#0x1

	ubfx r5,r4,#0x12,#0x1
	bfi r7,r5,#0xb,#0x1
	//
	ubfx r5,r3,#0x03,#0x1
	bfi r7,r5,#0xc,#0x1

	ubfx r5,r3,#0x13,#0x1
	bfi r7,r5,#0xd,#0x1

	ubfx r5,r4,#0x03,#0x1
	bfi r7,r5,#0xe,#0x1

	ubfx r5,r4,#0x13,#0x1
	bfi r7,r5,#0xf,#0x1


	// third byte

	ubfx r5,r3,#0x04,#0x1
	bfi r7,r5,#0x10,#0x1

	ubfx r5,r3,#0x14,#0x1
	bfi r7,r5,#0x11,#0x1

	ubfx r5,r4,#0x04,#0x1
	bfi r7,r5,#0x12,#0x1

	ubfx r5,r4,#0x14,#0x1
	bfi r7,r5,#0x13,#0x1
	//
	ubfx r5,r3,#0x05,#0x1
	bfi r7,r5,#0x14,#0x1

	ubfx r5,r3,#0x15,#0x1
	bfi r7,r5,#0x15,#0x1

	ubfx r5,r4,#0x05,#0x1
	bfi r7,r5,#0x16,#0x1

	ubfx r5,r4,#0x15,#0x1
	bfi r7,r5,#0x17,#0x1

	// fourth byte

	ubfx r5,r3,#0x06,#0x1
	bfi r7,r5,#0x18,#0x1

	ubfx r5,r3,#0x16,#0x1
	bfi r7,r5,#0x19,#0x1

	ubfx r5,r4,#0x06,#0x1
	bfi r7,r5,#0x1a,#0x1

	ubfx r5,r4,#0x16,#0x1
	bfi r7,r5,#0x1b,#0x1
	//
	ubfx r5,r3,#0x07,#0x1
	bfi r7,r5,#0x1c,#0x1

	ubfx r5,r3,#0x17,#0x1
	bfi r7,r5,#0x1d,#0x1

	ubfx r5,r4,#0x07,#0x1
	bfi r7,r5,#0x1e,#0x1

	ubfx r5,r4,#0x17,#0x1
	bfi r7,r5,#0x1f,#0x1


	// end of word one, next word now contains the upper 32-bits


	ubfx r5,r3,#0x08,#0x1		// load the first bit
	bfi r8,r5,#0x0,#0x1

	ubfx r5,r3,#0x18,#0x1		// load the next bit from state into r5
	bfi r8,r5,#0x1,#0x1

	ubfx r5,r4,#0x08,#0x1		// from here, same as above with all the bits
	bfi r8,r5,#0x2,#0x1

	ubfx r5,r4,#0x18,#0x1
	bfi r8,r5,#0x3,#0x1
	//
	ubfx r5,r3,#0x09,#0x1
	bfi r8,r5,#0x4,#0x1

	ubfx r5,r3,#0x19,#0x1
	bfi r8,r5,#0x5,#0x1

	ubfx r5,r4,#0x09,#0x1
	bfi r8,r5,#0x6,#0x1

	ubfx r5,r4,#0x19,#0x1
	bfi r8,r5,#0x7,#0x1

	// second byte

	ubfx r5,r3,#0x0a,#0x1
	bfi r8,r5,#0x8,#0x1

	ubfx r5,r3,#0x1a,#0x1
	bfi r8,r5,#0x9,#0x1

	ubfx r5,r4,#0x0a,#0x1
	bfi r8,r5,#0xa,#0x1

	ubfx r5,r4,#0x1a,#0x1
	bfi r8,r5,#0xb,#0x1
	//
	ubfx r5,r3,#0x0b,#0x1
	bfi r8,r5,#0xc,#0x1

	ubfx r5,r3,#0x1b,#0x1
	bfi r8,r5,#0xd,#0x1

	ubfx r5,r4,#0x0b,#0x1
	bfi r8,r5,#0xe,#0x1

	ubfx r5,r4,#0x1b,#0x1
	bfi r8,r5,#0xf,#0x1

	// third byte

	ubfx r5,r3,#0x0c,#0x1
	bfi r8,r5,#0x10,#0x1

	ubfx r5,r3,#0x1c,#0x1
	bfi r8,r5,#0x11,#0x1

	ubfx r5,r4,#0x0c,#0x1
	bfi r8,r5,#0x12,#0x1

	ubfx r5,r4,#0x1c,#0x1
	bfi r8,r5,#0x13,#0x1
	//
	ubfx r5,r3,#0x0d,#0x1
	bfi r8,r5,#0x14,#0x1

	ubfx r5,r3,#0x1d,#0x1
	bfi r8,r5,#0x15,#0x1

	ubfx r5,r4,#0x0d,#0x1
	bfi r8,r5,#0x16,#0x1

	ubfx r5,r4,#0x1d,#0x1
	bfi r8,r5,#0x17,#0x1

	// fourth byte

	ubfx r5,r3,#0x0e,#0x1
	bfi r8,r5,#0x18,#0x1

	ubfx r5,r3,#0x1e,#0x1
	bfi r8,r5,#0x19,#0x1

	ubfx r5,r4,#0x0e,#0x1
	bfi r8,r5,#0x1a,#0x1

	ubfx r5,r4,#0x1e,#0x1
	bfi r8,r5,#0x1b,#0x1
	//
	ubfx r5,r3,#0x0f,#0x1
	bfi r8,r5,#0x1c,#0x1

	ubfx r5,r3,#0x1f,#0x1
	bfi r8,r5,#0x1d,#0x1

	ubfx r5,r4,#0x0f,#0x1
	bfi r8,r5,#0x1e,#0x1

	ubfx r5,r4,#0x1f,#0x1
	bfi r8,r5,#0x1f,#0x1

	// permutation done

	mov r3,r7			// move lower word into state
	mov r4,r8			// move upper word into state

	pop {r7-r12,pc}

revert_sbox:
	push {r7-r12,lr}

	ubfx r5,r3,#0x0,#0x8			// load first lower state byte into r5
	adr r6,present_inverse_sbox		// load sbox into r6
	add r6,r5						// move sbox pointer at position state[byte]
	ldrb r7,[r6]					// load byte
	and r3,#0xFFFFFF00				// make free space for the new byte
	eor r3,r7						// move new byte into state

	ubfx r5,r3,#0x8,#0x8			// same as above with second byte of lower state
	adr r6,present_inverse_sbox
	add r6,r5
	ldrb r7,[r6]
	and r3,#0xFFFF00FF
	eor r3,r3,r7, lsl 0x8

	ubfx r5,r3,#0x10,#0x8			// same as above with third byte of lower state
	adr r6,present_inverse_sbox
	add r6,r5
	ldrb r7,[r6]
	and r3,#0xFF00FFFF
	eor r3,r3,r7, lsl 0x10

	ubfx r5,r3,#0x18,#0x8			// same as above with fourth byte of lower state
	adr r6,present_inverse_sbox
	add r6,r5
	ldrb r7,[r6]
	and r3,#0x00FFFFFF
	eor r3,r3,r7, lsl 0x18

	ubfx r5,r4,#0x0,#0x8			// same as above with first byte of UPPER state
	adr r6,present_inverse_sbox
	add r6,r5
	ldrb r7,[r6]
	and r4,#0xFFFFFF00
	eor r4,r7

	ubfx r5,r4,#0x8,#0x8			// same as above with second byte of upper state
	adr r6,present_inverse_sbox
	add r6,r5
	ldrb r7,[r6]
	and r4,#0xFFFF00ff
	eor r4,r4,r7,lsl #0x8

	ubfx r5,r4,#0x10,#0x8			// same as above with third byte of upper state
	adr r6,present_inverse_sbox
	add r6,r5
	ldrb r7,[r6]
	and r4,#0xFF00FFFF
	eor r4,r4,r7,lsl #0x10

	ubfx r5,r4,#0x18,#0x8			// same as above with fourth byte of upper state
	adr r6,present_inverse_sbox
	add r6,r5
	ldrb r7,[r6]
	and r4,r4,#0x00FFFFFF
	eor r4,r4,r7,lsl #0x18

	pop {r7-r12,pc}


present_inverse_sbox:
.byte 0x55, 0x5e, 0x5f, 0x58, 0x5c, 0x51, 0x52, 0x5d, 0x5b, 0x54, 0x56, 0x53, 0x50,	0x57, 0x59, 0x5a, 0xe5, 0xee, 0xef, 0xe8, 0xec, 0xe1, 0xe2, 0xed, 0xeb,	0xe4, 0xe6, 0xe3, 0xe0, 0xe7, 0xe9, 0xea, 0xf5, 0xfe, 0xff, 0xf8, 0xfc,	0xf1, 0xf2, 0xfd, 0xfb, 0xf4, 0xf6, 0xf3, 0xf0, 0xf7, 0xf9, 0xfa, 0x85,	0x8e, 0x8f, 0x88, 0x8c, 0x81, 0x82, 0x8d, 0x8b, 0x84, 0x86, 0x83, 0x80,	0x87, 0x89, 0x8a, 0xc5, 0xce, 0xcf, 0xc8, 0xcc, 0xc1, 0xc2, 0xcd, 0xcb,	0xc4, 0xc6, 0xc3, 0xc0, 0xc7, 0xc9, 0xca, 0x15, 0x1e, 0x1f, 0x18, 0x1c,	0x11, 0x12, 0x1d, 0x1b, 0x14, 0x16, 0x13, 0x10, 0x17, 0x19, 0x1a, 0x25,	0x2e, 0x2f, 0x28, 0x2c, 0x21, 0x22, 0x2d, 0x2b, 0x24, 0x26, 0x23, 0x20,	0x27, 0x29, 0x2a, 0xd5, 0xde, 0xdf, 0xd8, 0xdc, 0xd1, 0xd2, 0xdd, 0xdb,	0xd4, 0xd6, 0xd3, 0xd0, 0xd7, 0xd9, 0xda, 0xb5, 0xbe, 0xbf, 0xb8, 0xbc,	0xb1, 0xb2, 0xbd, 0xbb, 0xb4, 0xb6, 0xb3, 0xb0, 0xb7, 0xb9, 0xba, 0x45,	0x4e, 0x4f, 0x48, 0x4c, 0x41, 0x42, 0x4d, 0x4b, 0x44, 0x46, 0x43, 0x40,	0x47, 0x49, 0x4a, 0x65, 0x6e, 0x6f, 0x68, 0x6c, 0x61, 0x62, 0x6d, 0x6b,	0x64, 0x66, 0x63, 0x60, 0x67, 0x69, 0x6a, 0x35, 0x3e, 0x3f, 0x38, 0x3c,	0x31, 0x32, 0x3d, 0x3b, 0x34, 0x36, 0x33, 0x30, 0x37, 0x39, 0x3a, 0x05,	0x0e, 0x0f, 0x08, 0x0c, 0x01, 0x02, 0x0d, 0x0b, 0x04, 0x06, 0x03, 0x00,	0x07, 0x09, 0x0a, 0x75, 0x7e, 0x7f, 0x78, 0x7c, 0x71, 0x72, 0x7d, 0x7b,	0x74, 0x76, 0x73, 0x70, 0x77, 0x79, 0x7a, 0x95, 0x9e, 0x9f, 0x98, 0x9c,	0x91, 0x92, 0x9d, 0x9b, 0x94, 0x96, 0x93, 0x90, 0x97, 0x99, 0x9a, 0xa5,	0xae, 0xaf, 0xa8, 0xac, 0xa1, 0xa2, 0xad, 0xab, 0xa4, 0xa6, 0xa3, 0xa0,	0xa7, 0xa9, 0xaa

